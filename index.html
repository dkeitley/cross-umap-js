<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Visualising Rabbit-Mouse similarity</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>

		<select id="dir_dropdown">
			<option value="rm">Rabbit-Mouse</option>
			<option value="mr">Mouse-Rabbit</option>
		</select>

		<button type="button" id="clear_button">Clear</button>

		<script src="https://d3js.org/d3.v7.min.js"></script>

		<script type="module">
			import * as THREE from './js/three.module.js';
			import { OrbitControls } from './js/OrbitControls.js';
			import { FontLoader } from './js/FontLoader.js';
			import { TextGeometry } from './js/TextGeometry.js';


			let camera, scene, renderer;

			const pointer = new THREE.Vector2();

			const raycaster = new THREE.Raycaster();
			raycaster.params.Points.threshold = 0.1;

			let r_data, m_data;

			let r_points;
			let m_points;

			const r_ids = [];
			const r_positions = [];
			const r_colours = [];

			const m_ids = [];
			const m_positions = [];
			const m_colours = [];

			let nhood_sim;


			const mnns = [];
			const lines = [];

			let r_selected;
			let r_clicked;

			const r_mean = [];
			const m_mean = [];

			var direction="rm";

			let sim_max;
			let sim_min;

			const opacity_low = 0.2;

			const colour = new THREE.Color();
			const viridis_scale = d3.scaleSequential().domain([0,1])
  							.interpolator(d3.interpolateViridis);


  			function loadSim(direction="rm") {
				const load_sim = d3.json("data/" + direction + "_nhood_sim.json").then(nhoods => {
					nhood_sim=nhoods;

					// TODO: Not sure if there's a way to avoid 2 loops
					// Normalise colour range by finding min/max
					var sims = [];
					for(var key in nhoods) {
						var nhood = nhoods[key];
						sims.push(nhood.sim[0]);
					}
					sim_min = d3.min(sims);
					sim_max = d3.max(sims);

					var k=0
					for(var key in nhoods) {
						var nhood = nhoods[key];

						const line_points = [];

						// Create mapping lines
						var line_geometry = new THREE.BufferGeometry();
						const line = new THREE.LineSegments(
				    		line_geometry,
				    		new THREE.LineBasicMaterial({
				    			color:new THREE.Color(d3.interpolateTurbo((nhood.sim[0]-sim_min)/(sim_max-sim_min))) 
				    		})
				 		);

						// For each mapping
						let r_index, m_index;
						for(var i in nhood.index) {

							if(direction=="rm") {
								r_index = k;	
								m_index = nhood.index[i] -1;
							} else {
								r_index = nhood.index[i] -1;	
								m_index = k;
							}

							line_points.push(new THREE.Vector3(r_points.geometry.attributes.position.getX(r_index),
							r_points.geometry.attributes.position.getY(r_index),r_points.geometry.attributes.position.getZ(r_index)));

							line_points.push(new THREE.Vector3(m_points.geometry.attributes.position.getX(m_index),
							m_points.geometry.attributes.position.getY(m_index),m_points.geometry.attributes.position.getZ(m_index)));
							line_geometry.setFromPoints(line_points);
						}

						line_geometry.verticesNeedUpdate = true;
						line.visible = false;
						lines.push(line);
						scene.add(line);

						k = k + 1;
					}

				});

			}


			function init() {

				document.getElementById("clear_button").addEventListener("click", deselect, false);
				document.getElementById("dir_dropdown").addEventListener("change", changeDirection);

				const sprite = new THREE.TextureLoader().load( 'res/disc.png' );

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

				// Load rabbit nhoods...
				r_data = d3.tsv("data/rabbit_nhoods.tsv").then(data => {
					data.forEach(d => {

						d.umapX = Number(d.umapX);
						d.umapY = Number(d.umapY);
						d.umapZ = Number(d.umapZ);

						d.faX = Number(d.faX)*20;
						d.faY = Number(d.faY)*20;

						d.celltype = d.celltype;
						d.colour = d.colour;

						colour.set(d.colour);
						
						r_positions.push(d.umapX-20,d.umapY,d.umapZ);
						//r_positions.push(d.faX-20,d.faY,0);
						r_colours.push(colour.r,colour.g,colour.b,1);

					})

					// Used to position text
					r_mean.push(d3.mean(data, d => d.umapX)-20);
					r_mean.push(d3.mean(data, d => d.umapY));
					r_mean.push(d3.mean(data, d => d.umapZ));


					// Create threejs points
					const r_geometry = new THREE.BufferGeometry();
					r_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( r_positions, 3 ) );
					r_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( r_colours, 4 ) );
					r_geometry.computeBoundingSphere();

					const r_material = new THREE.PointsMaterial( { size:0.7,vertexColors:true,
						map:sprite,transparent: true,alphaTest: 0.8} );

					r_points = new THREE.Points(r_geometry,r_material);
					scene.add( r_points );


				});


				// Load mouse nhoods...
				m_data = d3.tsv("data/mouse_nhoods.tsv").then(data => {
					data.forEach(d => {
						d.umapX = Number(d.umapX);
						d.umapY = Number(d.umapY);
						d.umapZ = Number(d.umapZ);

						d.faX = Number(d.faX)*20;
						d.faY = Number(d.faY)*20;

						d.celltype = d.celltype;
						d.colour = d.colour;

						colour.set(d.colour);
						m_positions.push(d.umapX+20,d.umapY,d.umapZ);
						//m_positions.push(d.faX+20,d.faY,0);
						m_colours.push(colour.r,colour.g,colour.b,opacity_low);

					})

					// Used to position text
					m_mean.push(d3.mean(data, d => d.umapX)+20);
					m_mean.push(d3.mean(data, d => d.umapY));
					m_mean.push(d3.mean(data, d => d.umapZ));

					const m_geometry = new THREE.BufferGeometry();
					m_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( m_positions, 3 ) );
					m_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( m_colours, 4 ) );


					m_geometry.computeBoundingSphere();
					//const m_material = new THREE.PointsMaterial( { size:0.3,vertexColors:true} );
					const m_material = new THREE.PointsMaterial( { size:0.7,vertexColors:true,map:sprite,transparent: true,alphaTest: 0.175} );
					m_points = new THREE.Points(m_geometry,m_material);
					scene.add( m_points );


				});

				

				// Load neighbour mappings...
				Promise.all([r_data,m_data]).then((values) => {
					loadSim();
				});


				// Add ambient light
				const light = new THREE.AmbientLight(0xffffff);
				scene.add(light);

				// Add text labels
				Promise.all([r_data,m_data]).then((values) => {
					// TODO: Need smarter way to position text relative to points
					createText("Rabbit", r_mean[0], 20, r_mean[2]);
					createText("Mouse", m_mean[0]-2, 15, m_mean[2]);
				})
				
				
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
			
				camera.position.z = 30;
				scene.userData.camera = camera;

				const controls = new OrbitControls( camera, renderer.domElement );
				scene.userData.controls = controls;

			}


			// Loads helvetica font 
			function createText(text,x,y,z) {
				const loader = new FontLoader();
				loader.load( '/res/' + "helvetiker" + '_' + "regular" + '.typeface.json', function ( response ) {
					var font = response;
					addText(text,x,y,z,font);
					return(font)

				} );

			}


			// Builds text geometry and adds to scene
			function addText(text,x,y,z,font) {

				var text_geo = new TextGeometry( text ,{font:font,
					size:2,
					height: 0.5,
					curveSegments: 4,
					bevelEnabled: false});

				text_geo.computeBoundingBox();
				
				var materials = [
					new THREE.MeshPhongMaterial( { color: 0xfffffff, flatShading: true } ), // front
					new THREE.MeshPhongMaterial( { color: 0x808080  } ) // side
				];

				var text_mesh = new THREE.Mesh( text_geo, materials );

				text_mesh.position.x = x;
				text_mesh.position.y = y;
				text_mesh.position.z = z;

				scene.add(text_mesh);
			}



			function changeNeighbourOpacity(index,opacity) {
				var r_nhood =  Object.keys(nhood_sim)[index];

				for(var i in nhood_sim[r_nhood].index) {
					var m_index = nhood_sim[r_nhood].index[i] - 1;
					m_points.geometry.attributes.color.setXYZW(m_index, 
						m_points.geometry.attributes.color.getX(m_index), 
						m_points.geometry.attributes.color.getY(m_index), 
						m_points.geometry.attributes.color.getZ(m_index),opacity); 
				}		
			}

			function changeOpacity(points,opacity) {
				for(let i=0; i< points.geometry.attributes.color.count; i++) {
					points.geometry.attributes.color.setXYZW(i, 
						points.geometry.attributes.color.getX(i), 
						points.geometry.attributes.color.getY(i), 
						points.geometry.attributes.color.getZ(i),opacity); 
				}
				points.geometry.attributes.color.needsUpdate = true;
			}

			

			
			function onHover(event) {
				event.preventDefault();


				if(!r_clicked) {

					if(r_selected) {
						lines[r_selected].visible = false;
						changeNeighbourOpacity(r_selected, opacity_low);
					}

					pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					pointer.y = - ((event.clientY - renderer.domElement.offsetTop)/ window.innerHeight ) * 2 + 1;

					// Only raycast if not panning (optimization)
					var hits;
					raycaster.setFromCamera(pointer, scene.userData.camera);

					// Raycast to single point
					hits = raycaster.intersectObject(r_points, false);


					// Run if we have intersections
					if (hits.length > 0) {
						var index = hits[0].index;
						lines[index].visible = true; // Get lines associated with point
						changeNeighbourOpacity(index,1);
						r_selected = index;
						
					 renderer.render(scene, scene.userData.camera);

					}
				}
			}



			function onClick(event) {
				event.preventDefault();

				if(!r_clicked & r_selected) {
					lines[r_selected].visible = false;
					changeNeighbourOpacity(r_selected,opacity_low);
				}

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ((event.clientY - renderer.domElement.offsetTop)/ window.innerHeight ) * 2 + 1;

				// Only raycast if not panning (optimization)
				var hits;
				raycaster.setFromCamera(pointer, scene.userData.camera);

				// Raycast to single object
				hits = raycaster.intersectObject(r_points, false);

				// Run if we have intersections
				if (hits.length > 0) {
					var index = hits[0].index;

					// Remove previously clicked mapping
					if(r_clicked & r_clicked!=index) {
						lines[r_clicked].visible = false;
						changeNeighbourOpacity(r_clicked,opacity_low);
					}

					// Show mapping
					lines[index].visible = true;
					changeNeighbourOpacity(index,1);
					r_clicked = index;

					
				 renderer.render(scene, scene.userData.camera);
				}

			}

			const animate = function () {
				requestAnimationFrame( animate );
				window.addEventListener('mousemove', onHover, false);
				window.addEventListener('click', onClick, false);
				Promise.all([m_data]).then((values) => {m_points.geometry.attributes.color.needsUpdate = true;});
				renderer.render( scene, camera );
			};

			function changeDirection() {
				var dir_selected = document.getElementById("dir_dropdown").value
				if (dir_selected!= direction){
					console.log("Changing direction to - " + dir_selected);
					direction = dir_selected;
					
					if(dir_selected == "mr") {

						// change opacity
						r_points.material._alphaTest = 0.175;
						r_points.material.needsUpdate = true;
						changeOpacity(r_points,opacity_low);

						m_points.material._alphaTest = 0.8;
						m_points.material.needsUpdate = true;
						changeOpacity(m_points,1);

						

					} else{

						// change opacity
						m_points.material._alphaTest = 0.175;
						m_points.material.needsUpdate = true;
						changeOpacity(m_points,opacity_low);

						r_points.material._alphaTest = 0.8;
						r_points.material.needsUpdate = true;
						changeOpacity(r_points,1);

					}

					


					console.log(r_points);
					console.log(m_points);
					//loadSim(direction);

				}

			}


			// Remove mapping currently being displayed
			function deselect() {
				if(r_clicked) {
					lines[r_clicked].visible = false;
					changeNeighbourOpacity(r_clicked,0.2);
					r_clicked = undefined;
				}
			}


			


			init();
			animate();
			

		</script>
		
	</body>
</html>

<!DOCTYPE html>
