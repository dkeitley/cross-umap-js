<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="https://d3js.org/d3.v7.min.js"></script>

		<script type="module">
			import * as THREE from './js/three.module.js';
			import { OrbitControls } from './js/OrbitControls.js';
			import { FontLoader } from './js/FontLoader.js';
			import { TextGeometry } from './js/TextGeometry.js';


			let camera, scene, renderer;

			const pointer = new THREE.Vector2();

			const raycaster = new THREE.Raycaster();
			raycaster.params.Points.threshold = 0.1;

			let r_points;
			let m_points;

			const r_ids = [];
			const r_positions = [];
			const r_colours = [];

			const m_ids = [];
			const m_positions = [];
			const m_colours = [];

			let nhood_sim;


			const mnns = [];
			const lines = [];

			let r_selected;
			let r_clicked;

			const r_mean = [];
			const m_mean = [];

			const opacity_low = 0.2;

			const colour = new THREE.Color();
			const viridis_scale = d3.scaleSequential().domain([0,1])
  							.interpolator(d3.interpolateViridis);


			function init() {

				document.getElementById("clear_button").addEventListener ("click", deselect, false);

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

				const sprite = new THREE.TextureLoader().load( 'res/disc.png' );


				// Load rabbit nhoods
				const r_data = d3.tsv("data/rabbit_nhoods.tsv").then(data => {
					data.forEach(d => {
						d.umapX = Number(d.umapX);
						d.umapY = Number(d.umapY);
						d.umapZ = Number(d.umapZ);

						d.colour = d.colour;
						d.celltype = d.celltype;

						colour.set(d.colour);
						r_positions.push(d.umapX-20,d.umapY,d.umapZ);
						//rabbit_celltypes.push(d.celltype);
						r_colours.push(colour.r,colour.g,colour.b);

					})

					r_mean.push(d3.mean(data, d => d.umapX)-20);
					r_mean.push(d3.mean(data, d => d.umapY));
					r_mean.push(d3.mean(data, d => d.umapZ));

					const r_geometry = new THREE.BufferGeometry();
					r_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( r_positions, 3 ) );
					r_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( r_colours, 3 ) );
					r_geometry.computeBoundingSphere();
					//const r_material = new THREE.PointsMaterial( { size:0.3,vertexColors:true} );
					const r_material = new THREE.PointsMaterial( { size:0.7,vertexColors:true,map:sprite,transparent: true,alphaTest: opacity_low} );
					r_points = new THREE.Points(r_geometry,r_material);
					scene.add( r_points );


				});


				// Load mouse nhoods
				const m_data = d3.tsv("data/mouse_nhoods.tsv").then(data => {
					data.forEach(d => {
						d.umapX = Number(d.umapX);
						d.umapY = Number(d.umapY);
						d.umapZ = Number(d.umapZ);

						d.colour = d.colour;
						d.celltype = d.celltype;

						colour.set(d.colour);
						m_positions.push(d.umapX+20,d.umapY,d.umapZ);
						m_colours.push(colour.r,colour.g,colour.b,opacity_low);

					})

					m_mean.push(d3.mean(data, d => d.umapX)+20);
					m_mean.push(d3.mean(data, d => d.umapY));
					m_mean.push(d3.mean(data, d => d.umapZ));

					const m_geometry = new THREE.BufferGeometry();
					m_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( m_positions, 3 ) );
					m_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( m_colours, 4 ) );


					m_geometry.computeBoundingSphere();
					//const m_material = new THREE.PointsMaterial( { size:0.3,vertexColors:true} );
					const m_material = new THREE.PointsMaterial( { size:0.7,vertexColors:true,map:sprite,transparent: true,alphaTest: 0.1} );
					m_points = new THREE.Points(m_geometry,m_material);
					scene.add( m_points );


				});


				// Only after data loaded...
				Promise.all([r_data,m_data]).then((values) => {
					const load_sim = d3.json("data/nhood_sim.json").then(nhoods => {
						nhood_sim=nhoods;
						var k=0
						for(var key in nhoods) {
							var nhood = nhoods[key];

							const line_points = [];

							var line_geometry = new THREE.BufferGeometry();
							//line_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute(,1 ) );
							const line = new THREE.LineSegments(
					    		line_geometry,
					    		new THREE.LineBasicMaterial()
					 		);

							// For each neighbour neighbourhood
							for(var i in nhood.index) {
								var nn = nhood.index[i] -1;
								line_points.push(new THREE.Vector3(r_points.geometry.attributes.position.getX(k),
								r_points.geometry.attributes.position.getY(k),r_points.geometry.attributes.position.getZ(k)));

								line_points.push(new THREE.Vector3(m_points.geometry.attributes.position.getX(nn),
								m_points.geometry.attributes.position.getY(nn),m_points.geometry.attributes.position.getZ(nn)));
								line_geometry.setFromPoints(line_points);

							}

							line_geometry.verticesNeedUpdate = true;
							line.visible = false;
							lines.push(line);
							scene.add(line);

							k = k + 1;

						}

					});
					
				});


				const light = new THREE.AmbientLight(0xffffff);
				scene.add(light);
				

				Promise.all([r_data,m_data]).then((values) => {
					console.log(r_mean);
					loadFont("Rabbit", r_mean[0], 20, r_mean[2]);
					loadFont("Mouse", m_mean[0]-2, 15, m_mean[2]);
				})
				
				//createText("Rabbit", )
				
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
			
				camera.position.z = 30;
				scene.userData.camera = camera;

				const controls = new OrbitControls( camera, renderer.domElement );
				scene.userData.controls = controls;

			}

			function loadFont(text,x,y,z) {
				const loader = new FontLoader();
				loader.load( '/res/' + "helvetiker" + '_' + "regular" + '.typeface.json', function ( response ) {

					var font = response;
					console.log(font);
					createText(text,x,y,z,font);

					return(font)

				} );

			}


			function createText(text,x,y,z,font) {

				var text_geo = new TextGeometry( text ,{font:font,
					size:2,
					height: 0.5,
					curveSegments: 4,

					bevelEnabled: false});
				text_geo.computeBoundingBox();
				
				var materials = [
					new THREE.MeshPhongMaterial( { color: 0xfffffff, flatShading: true } ), // front
					new THREE.MeshPhongMaterial( { color: 0x808080  } ) // side
				];


				var text_mesh = new THREE.Mesh( text_geo, materials );

				text_mesh.position.x = x;
				text_mesh.position.y = y;
				text_mesh.position.z = z;

				scene.add(text_mesh);

			}


			function changeOpacity(index,opacity) {
				var r_nhood =  Object.keys(nhood_sim)[index];

				for(var i in nhood_sim[r_nhood].index) {
					var m_index = nhood_sim[r_nhood].index[i] - 1;
					m_points.geometry.attributes.color.setXYZW(m_index, 
						m_points.geometry.attributes.color.getX(m_index), 
						m_points.geometry.attributes.color.getY(m_index), 
						m_points.geometry.attributes.color.getZ(m_index),opacity); 
				}
						

			}

			

			// Raycast when we click the mouse
			function onHover(event) {
				event.preventDefault();

				//console.log(r_points);

				if(!r_clicked) {

					if(r_selected) {
						lines[r_selected].visible = false;
						changeOpacity(r_selected, opacity_low);
					
					}

					pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					pointer.y = - ((event.clientY - renderer.domElement.offsetTop)/ window.innerHeight ) * 2 + 1;

					// Only raycast if not panning (optimization)
					var hits;
					raycaster.setFromCamera(pointer, scene.userData.camera);

					// Raycast to single object
					hits = raycaster.intersectObject(r_points, false);

					// Raycast to multiple objects
					//hits = raygun.intersectObjects([myTargetObect, myTargetObect2]);
					

					// Run if we have intersections
					if (hits.length > 0) {

						// Get lines associated with point
						var index = hits[0].index;
						var cellX = r_points.geometry.attributes.position.getX(index);
						var cellY = r_points.geometry.attributes.position.getY(index);
						var cellZ = r_points.geometry.attributes.position.getZ(index);

						lines[index].visible = true;
						changeOpacity(index,1);
						



						//var test = new THREE.Color(d3.interpolateViridis(nhood_sim[sim_index].sim[0]));
						//consoleconsole.log(test);
						//console.log(lines[index]);
						//lines[index].geometry.attributes.color.setXYZ(test);
						

						
						r_selected = index;

						
					 renderer.render(scene, scene.userData.camera);
					}
				}
			}


			function onClick(event) {
				event.preventDefault();

				if(!r_clicked & r_selected) {
					lines[r_selected].visible = false;
					changeOpacity(r_selected,opacity_low);
				}

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ((event.clientY - renderer.domElement.offsetTop)/ window.innerHeight ) * 2 + 1;

				// Only raycast if not panning (optimization)
				var hits;
				raycaster.setFromCamera(pointer, scene.userData.camera);

				// Raycast to single object
				hits = raycaster.intersectObject(r_points, false);


				// Run if we have intersections
				if (hits.length > 0) {

					

					// Get lines associated with point
					var index = hits[0].index;

					if(r_clicked & r_clicked!=index) {
						lines[r_clicked].visible = false;
						changeOpacity(r_clicked,opacity_low);
					}

					lines[index].visible = true;
					changeOpacity(index,1);
					r_clicked = index;

					
				 renderer.render(scene, scene.userData.camera);
				}

			}


			function deselect() {
				if(r_clicked) {
					lines[r_clicked].visible = false;
					changeOpacity(r_clicked,0.2);
					r_clicked = undefined;
				}
			}


			const animate = function () {
				requestAnimationFrame( animate );
				window.addEventListener('mousemove', onHover, false);
				window.addEventListener('click', onClick, false);
				m_points.geometry.attributes.color.needsUpdate = true;
				renderer.render( scene, camera );
			};


			init();
			animate();
			

		</script>
		<button type="button" id="clear_button">Clear</button>



	</body>
</html>



<!DOCTYPE html>
