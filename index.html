<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="https://d3js.org/d3.v7.min.js"></script>

		<script type="module">
			import * as THREE from './js/three.module.js';
			import { OrbitControls } from './js/OrbitControls.js';

			let camera, scene, renderer;

			const pointer = new THREE.Vector2();

			const raycaster = new THREE.Raycaster();
			raycaster.params.Points.threshold = 0.1;

			let r_points;
			let m_points;

			const r_ids = [];
			const r_positions = [];
			const r_colours = [];

			const m_ids = [];
			const m_positions = [];
			const m_colours = [];

			let nhood_sim;


			const mnns = [];
			const lines = [];

			let r_selected;

			const colour = new THREE.Color();
			const viridis_scale = d3.scaleSequential().domain([0,1])
  							.interpolator(d3.interpolateViridis);


			function init() {

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

				const sprite = new THREE.TextureLoader().load( 'res/disc.png' );


				// Load rabbit nhoods
				const r_data = d3.tsv("data/rabbit_nhoods.tsv").then(data => {
					data.forEach(d => {
						d.umapX = Number(d.umapX);
						d.umapY = Number(d.umapY);
						d.umapZ = Number(d.umapZ);

						d.colour = d.colour;
						d.celltype = d.celltype;

						colour.set(d.colour);
						r_positions.push(d.umapX-20,d.umapY,d.umapZ);
						//rabbit_celltypes.push(d.celltype);
						r_colours.push(colour.r,colour.g,colour.b);

					})

					const r_geometry = new THREE.BufferGeometry();
					r_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( r_positions, 3 ) );
					r_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( r_colours, 3 ) );
					r_geometry.computeBoundingSphere();
					//const r_material = new THREE.PointsMaterial( { size:0.3,vertexColors:true} );
					const r_material = new THREE.PointsMaterial( { size:0.7,vertexColors:true,map:sprite,transparent: true,alphaTest: 0.8} );
					r_points = new THREE.Points(r_geometry,r_material);
					scene.add( r_points );


				});


				// Load mouse nhoods
				const m_data = d3.tsv("data/mouse_nhoods.tsv").then(data => {
					data.forEach(d => {
						d.umapX = Number(d.umapX);
						d.umapY = Number(d.umapY);
						d.umapZ = Number(d.umapZ);

						d.colour = d.colour;
						d.celltype = d.celltype;

						colour.set(d.colour);
						m_positions.push(d.umapX+20,d.umapY,d.umapZ);
						m_colours.push(colour.r,colour.g,colour.b);

					})

					const m_geometry = new THREE.BufferGeometry();
					m_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( m_positions, 3 ) );
					m_geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( m_colours, 3 ) );
					m_geometry.computeBoundingSphere();
					//const m_material = new THREE.PointsMaterial( { size:0.3,vertexColors:true} );
					const m_material = new THREE.PointsMaterial( { size:0.7,vertexColors:true,map:sprite,transparent: true,alphaTest: 0.8} );
					m_points = new THREE.Points(m_geometry,m_material);
					scene.add( m_points );


				});


				// Only after data loaded...
				Promise.all([r_data,m_data]).then((values) => {
					const load_sim = d3.json("data/nhood_sim.json").then(nhoods => {
						console.log(nhoods);
						var k=0
						for(var key in nhoods) {
							var nhood = nhoods[key];

							const line_points = [];

							var line_geometry = new THREE.BufferGeometry();
							const line = new THREE.Line(
					    		line_geometry,
					    		new THREE.LineBasicMaterial({ color: 0xffff99 })
					 		);

							// For each neighbour neighbourhood
							for(var i in nhood.index) {
								var nn = nhood.index[i] -1;
								line_points.push(new THREE.Vector3(r_points.geometry.attributes.position.getX(k),
								r_points.geometry.attributes.position.getY(k),r_points.geometry.attributes.position.getZ(k)));

								line_points.push(new THREE.Vector3(m_points.geometry.attributes.position.getX(nn),
								m_points.geometry.attributes.position.getY(nn),m_points.geometry.attributes.position.getZ(nn)));
								line_geometry.setFromPoints(line_points);

							}

							line_geometry.verticesNeedUpdate = true;
							line.visible = false;
							lines.push(line);
							scene.add(line);

							k = k + 1;

						}

					});
					
				});
				
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
			
				camera.position.z = 30;
				scene.userData.camera = camera;

				const controls = new OrbitControls( camera, renderer.domElement );
				scene.userData.controls = controls;

			}

			

			// Raycast when we click the mouse
			function onHover(event) {
				event.preventDefault();

				//console.log(r_points);

				if(r_selected) {
					lines[r_selected].visible = false;
				}

				pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				// Only raycast if not panning (optimization)
				var hits;
				raycaster.setFromCamera(pointer, scene.userData.camera);

				// Raycast to single object
				hits = raycaster.intersectObject(r_points, false);

				// Raycast to multiple objects
				//hits = raygun.intersectObjects([myTargetObect, myTargetObect2]);
				

				// Run if we have intersections
				if (hits.length > 0) {

					// Get lines associated with point
					var index = hits[0].index;
					var cellX = r_points.geometry.attributes.position.getX(index);
					var cellY = r_points.geometry.attributes.position.getY(index);
					var cellZ = r_points.geometry.attributes.position.getZ(index);

					lines[index].visible = true;
					r_selected = index;

					
				 renderer.render(scene, scene.userData.camera);
				}
			}


			const animate = function () {
				requestAnimationFrame( animate );
				window.addEventListener('mousemove', onHover, false);
				renderer.render( scene, camera );
			};


			init();
			animate();
			

		</script>
	</body>
</html>



<!DOCTYPE html>
